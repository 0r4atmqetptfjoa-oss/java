package com.example.educationalapp

import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.navigation.NavController
import kotlinx.coroutines.delay
import kotlin.random.Random

/**
 * A sliding puzzle game implemented on a 3x3 grid.  The player rearranges
 * numbered tiles by sliding them into the empty space until they are in
 * ascending order from 1 to 8.  Moves are counted, and solving the puzzle
 * awards stars.  The puzzle is generated by shuffling a solved board via
 * random valid moves to ensure solvability.
 */
@Composable
fun JigsawPuzzleScreen(navController: NavController, starState: MutableState<Int>) {
    // Board represented as a list of nine integers (0 = blank)
    var board by remember { mutableStateOf(generateBoard()) }
    var moves by remember { mutableStateOf(0) }
    var showEndDialog by remember { mutableStateOf(false) }

    fun isSolved(b: List<Int>) = b == listOf(1, 2, 3, 4, 5, 6, 7, 8, 0)

    fun swap(index: Int) {
        val blankIndex = board.indexOf(0)
        val row = index / 3
        val col = index % 3
        val blankRow = blankIndex / 3
        val blankCol = blankIndex % 3
        val manhattan = kotlin.math.abs(row - blankRow) + kotlin.math.abs(col - blankCol)
        if (manhattan == 1) {
            // swap tile with blank
            val newBoard = board.toMutableList()
            newBoard[blankIndex] = board[index]
            newBoard[index] = 0
            board = newBoard
            moves++
            if (isSolved(newBoard)) {
                showEndDialog = true
                // award more stars for solving a puzzle: 3 stars
                starState.value += 3
            }
        }
    }

    fun resetGame() {
        board = generateBoard()
        moves = 0
        showEndDialog = false
    }

    if (showEndDialog) {
        AlertDialog(
            onDismissRequest = { navController.navigate(Screen.MainMenu.route) },
            title = { Text("Felicitări!", textAlign = TextAlign.Center) },
            text = { Text("Ai rezolvat puzzle‑ul în $moves mutări.", textAlign = TextAlign.Center) },
            confirmButton = {
                Button(onClick = { resetGame() }) {
                    Text("Joacă din nou")
                }
            },
            dismissButton = {
                Button(onClick = { navController.navigate(Screen.MainMenu.route) }) {
                    Text("Meniu Principal")
                }
            }
        )
    }

    Box(modifier = Modifier.fillMaxSize()) {
        Image(
            painter = painterResource(id = R.drawable.bg_game_puzzle),
            contentDescription = null,
            contentScale = ContentScale.Crop,
            modifier = Modifier.fillMaxSize()
        )
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(16.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Text(text = "Puzzle", style = MaterialTheme.typography.headlineSmall, color = Color.White)
            Spacer(modifier = Modifier.height(8.dp))
            Text(text = "Mutări: $moves", color = Color.White)
            Spacer(modifier = Modifier.height(16.dp))
            // Grid of tiles
            for (row in 0 until 3) {
                Row {
                    for (col in 0 until 3) {
                        val index = row * 3 + col
                        val value = board[index]
                        Box(
                            modifier = Modifier
                                .size(80.dp)
                                .padding(4.dp)
                                .background(
                                    if (value == 0) Color.Transparent else MaterialTheme.colorScheme.primaryContainer,
                                    shape = MaterialTheme.shapes.medium
                                )
                                .border(1.dp, Color.White, shape = MaterialTheme.shapes.medium)
                                .clickable { swap(index) },
                            contentAlignment = Alignment.Center
                        ) {
                            if (value != 0) {
                                Text(text = value.toString(), style = MaterialTheme.typography.headlineMedium, color = MaterialTheme.colorScheme.onPrimaryContainer)
                            }
                        }
                    }
                }
            }
            Spacer(modifier = Modifier.height(16.dp))
            Button(onClick = { navController.navigate(Screen.MainMenu.route) }) {
                Text("Înapoi la Meniu")
            }
        }
    }
}

/**
 * Generates a solvable 3x3 sliding puzzle board by performing a sequence of
 * random valid moves starting from the solved state.  This approach avoids
 * generating unsolvable configurations without requiring inversion checks.
 */
private fun generateBoard(shuffleMoves: Int = 50): List<Int> {
    var board = mutableListOf(1, 2, 3, 4, 5, 6, 7, 8, 0)
    val directions = listOf(-1, 1, -3, 3) // left, right, up, down in 1D index form
    repeat(shuffleMoves) {
        val blankIndex = board.indexOf(0)
        val possibleMoves = directions.map { blankIndex + it }
            .filter { it in 0 until 9 }
            .filter { move ->
                // Prevent wrapping rows when moving left/right
                val blankRow = blankIndex / 3
                val moveRow = move / 3
                if (kotlin.math.abs(move - blankIndex) == 1) {
                    blankRow == moveRow
                } else {
                    true
                }
            }
        val swapIndex = possibleMoves.random()
        board[blankIndex] = board[swapIndex]
        board[swapIndex] = 0
    }
    return board.toList()
}